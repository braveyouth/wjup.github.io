<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[装deepin系统踩的坑]]></title>
    <url>%2F2019%2F07%2F10%2Fdeepin%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;周末逛论坛，发现linux桌面版系统，deepin做很漂亮，也是国产的。于是跳到官网瞟了一波。按照官网的帮助，下载了镜像，做了系统U盘。我先是在另一个淘汰的笔记本上安装测试的，发现正常。回到win10系统也正常，没啥异样。而且界面很美，MAC book既视感😂。&emsp;&emsp;于是大胆的在我工作笔记本上安装了起来。重启几次后来发现，安装的那个E盘被格式化重新写入数据了，而且在win10这边也不显示这个盘符。瞬间懵逼了，之前桌面都是放在E盘的，而且还有一些资料都没了。瞬间心疼，桌面快捷方式图标也没了。重要的是这个博客的大本营在这个盘下啊。了解next的都知道，重新搭建不难，主要是写的md博文源文件都丢了。而且主题配置也没了，当初浪费了很长时间才完成各种配置的啊（1天？）。唉，迫不得已。又重新搭建还原了博文，还好文章数量不是太多。不过发现这次整个博客比之前的更增添了很多东西。也美观了不是。&emsp;&emsp;不过这个deepin系统真香，界面的确挺美的。使用感受就是，和win10没啥区别，主要不同就是一个是linux支持，一个是windows支持。下面是当时安装好的截图。]]></content>
      <categories>
        <category>编程</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[午休醒来的懵逼发呆和思考人生]]></title>
    <url>%2F2019%2F07%2F03%2F%E5%8D%88%E4%BC%91%E9%86%92%E6%9D%A5%E7%9A%84%E6%87%B5%E9%80%BC%E5%8F%91%E5%91%86%E5%92%8C%E6%80%9D%E8%80%83%E4%BA%BA%E7%94%9F%2F</url>
    <content type="text"><![CDATA[嗯？我的腿呢？还在啊，怎么…卧槽！好麻！ 午休，中国传统习俗，不知是不是中国特有。之前看到一个段子这样说道：一位外国小哥第一天上班，中午出去吃完饭回来后，看到同事全躺下了，咋了中毒了？被偷袭了？差点没报警。（笑） 所以秉着传承习俗，发扬传统文化的理念。于是乎我也“卧倒”了~每日小憩醒来一瞬间，总会发现自己少了个腿，或着丢了个胳臂。懵逼过去后才发现是麻了。听网上说腿脚发麻是血液不畅通的缘故，于是我伸直了腿，蹦着身子成一条直线躺在椅子上，呆若木鸡，双眼无神，开始了思考人生。 为啥，我火急火燎的来到这个世界，为啥…（宋丹丹腔?）。嗯？情景不对，刚睡醒没这么激情。切换 记得小时候夏天的某个中午。自己玩累了，见爸妈都躺在床上午睡，占了大片的面积（床小家穷）。于是我找到了四五个化肥袋子，到大门口铺上睡了起来（小时候我家大门面朝东，所以太阳会被挡住，门口有些阴凉地）。 ….不想写了。敲代码]]></content>
      <categories>
        <category>生活</category>
        <category>日常</category>
      </categories>
      <tags>
        <tag>午觉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秘密花园]]></title>
    <url>%2F2019%2F07%2F02%2F%E7%A7%98%E5%AF%86%E8%8A%B1%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[Enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>生活</category>
        <category>后花园</category>
      </categories>
      <tags>
        <tag>加密文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中定时执行shell脚本]]></title>
    <url>%2F2019%2F07%2F02%2Flinux%E4%B8%AD%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;突发一股idea，我的linux服务器上的tomcat项目，虽然不能一直跑（别问我为啥不能一直跑，打开你的想象力），但是我可以设置个定时任务让他在固定时间启动和关闭啊。20大洋两个月的linux服务器，可不能浪费了，要榨干它所有的价值。对，榨干价值！于是利用定时任务在每天22点启动tomcat，早7点10分关闭它。&emsp;&emsp;因为买来的这个服务器自带crontab，而且操作简单，所以定时执行shell脚本的任务，选择了crontab。所以在此记录下。对于没有crontab的服务器，可以先安装下。 crontab的安装12yum install vixie-cronyum install crontabs vixie-cron软件包是cron的主程序；crontabs软件包是用来安装、卸装、或列举用来驱动 cron 守护进程的表格的程序。 crontab启动关闭等操作12345service crond start //启动服务 service crond stop //关闭服务 service crond restart //重启服务 service crond reload //重新载入配置service crond status //查看crontab服务状态 查看crontab服务是否已设置为开机启动，执行命令：ntsysv加入开机自动启动:chkconfig –level 35 crond on 也可以用设置开机自动启动crond服务:1chkconfig crond on 查看各个开机级别的crond服务运行情况1chkconfig –list crond crond 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭可以看到2、3、4、5级别开机会自动启动crond服务取消开机自动启动crond服务:1chkconfig crond off crontab定时任务操作12345cat /etc/crontab //查看crontab，会有注释说明crontab -u //设定特定用户的定时服务crontab -l //列出当前用户定时服务内容 crontab -r //删除当前用户的定时服务crontab -e //编辑当前用户的定时服务 先查看下crontab的状态 再看下crontab的所有定时任务 通过查看crontab知道，一行定时任务各部分的意思是啥 crontab添加配置解释* * * * * user_name command to be executed user_name 表示执行定时任务的用户 不指定默认当前用户 command to be executed 表示要执行的脚本语句。 前面五位*号是定时执行的时间周期 说明如下：第一个 * 表示分钟：取值范围0-59第二个 * 表示小时：取值范围0-23第三个 * 表示天数：取值范围1-31第四个 * 表示月份：取值范围1-12第五个 * 表示每周：取值范围0-6 使用(-)可以划定范围如：0 0-3 * * * 脚本表示每天0-3点整执行脚本 使用(,)可以枚举时间如: 0,15,30,45 * * * * 脚本表示每个小时的0分，15分，45分，30分会执行脚本 使用(/)可以指定间隔如：* */8 * * * 脚本表示每8小时执行脚本 组合用法0-20/10 * * * * 脚本表示在前20分钟内每隔10分钟执行脚本]]></content>
      <categories>
        <category>编程</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java后台对json进行加密、解密]]></title>
    <url>%2F2019%2F07%2F01%2Fjava%E5%90%8E%E5%8F%B0%E5%AF%B9json%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;由于热爱爬虫，爱分析数据，几个月前在手机上通过抓包软件，抓到某资源app的大量请求，捕获各种类型的api接口，获取了大量json数据，而且可以直接利用。于是发挥了我python爬虫的那点知识，不断循环爬取数据保存到数据库，最后爬取了近4万条可用有价值的数据。上周末本想继续爬取更新一波，发现json传输的数据都加密了，于是对json加密产生了兴趣，本想把这种传输方式应用到java-web中，发现前端并不是好处理来自后台传过来的加密json数据（知识尚浅？），所以在此只记录下java后端对json数据加密解密处理的代码逻辑，以下两种方式来源在页尾已注明。 方式一：AES加密123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import org.apache.commons.codec.binary.Base64;import javax.crypto.*;import javax.crypto.spec.SecretKeySpec;import java.security.SecureRandom;/** * Create by wjup on 2019/7/1 9:03 */public class AesUtil &#123; public static void main(String[] args) throws Exception &#123; // aes + base --&gt; aes + base String content = "&#123;\"mac\":\"123\",\"idfa\":\"123\",\"clientIp\":\"456\",insertTime\":\"test\"&#125;"; System.out.println("加密内容：" + content); String key = "123abc"; System.out.println("加密密钥和解密密钥：" + key); String encrypt = aesEncrypt(content, key); System.out.println("加密后：" + encrypt); String decrypt = aesDecrypt(encrypt, key); System.out.println("解密后：" + decrypt); &#125; /** * 编码 * * @param bstr * @return String */ public static String Base64encode(byte[] bstr) &#123; return Base64.encodeBase64String(bstr); &#125; /** * 解码 * * @param str * @return string */ public static byte[] Base64decode(String str) &#123; return Base64.decodeBase64(str); &#125; /* * AES加密 * @param content 待加密的内容 * @param encryptKey 加密密钥 * @return 加密后的byte[] * @throws Exception */ public static byte[] aesEncryptToBytes(String content, String encryptKey) throws Exception &#123; KeyGenerator kgen = KeyGenerator.getInstance("AES"); /*防止linux下 随机生成key*/ SecureRandom random = SecureRandom.getInstance("SHA1PRNG"); random.setSeed(encryptKey.getBytes()); kgen.init(128, random); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(kgen.generateKey().getEncoded(), "AES")); return cipher.doFinal(content.getBytes("UTF-8")); &#125; /** * AES加密为base 64 code * * @param content 待加密的内容 * @param encryptKey 加密密钥 * @return 加密后的base 64 code * @throws Exception */ public static String aesEncrypt(String content, String encryptKey) throws Exception &#123; return Base64encode(aesEncryptToBytes(content, encryptKey)); &#125; /** * AES解密 * * @param encryptBytes 待解密的byte[] * @param decryptKey 解密密钥 * @return 解密后的String * @throws Exception */ public static String aesDecryptByBytes(byte[] encryptBytes, String decryptKey) &#123; byte[] decryptBytes = new byte[0]; try &#123; KeyGenerator kgen = KeyGenerator.getInstance("AES"); /*防止linux下 随机生成key*/ SecureRandom random = SecureRandom.getInstance("SHA1PRNG"); random.setSeed(decryptKey.getBytes()); kgen.init(128, random); Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(kgen.generateKey().getEncoded(), "AES")); decryptBytes = cipher.doFinal(encryptBytes); return new String(decryptBytes, "UTF-8"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return decryptKey; &#125; /** * 将base 64 code AES解密 * * @param encryptStr 待解密的base 64 code * @param decryptKey 解密密钥 * @return 解密后的string * @throws Exception */ public static String aesDecrypt(String encryptStr, String decryptKey) &#123; return aesDecryptByBytes(Base64decode(encryptStr), decryptKey); &#125;&#125; 方式二：三重加密算法加密顺序：JSON字符串-&gt;Base64字符串-&gt;DES加密Base64是一重加密 Base64里面我改进了算法，支持任意形式的字典表，所以这个地方是第二重加密 DES在Base64的基础上再次用秘钥加密。 有人问为什么还需要改Base64的字典表，其实原因就是DES的秘钥只能是8个字节，按照现在计算机的处理速度，24小时就破解了。 Base64的处理类，这里我把网上一个公开的类库做了改进，做了一个混排编码格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.HashMap;/** * Create by wjup on 2019/7/1 9:08 */public class Base64 &#123; private static final char[] legalChars = "9ghijk67sutJKLM8rvwx4EzAlnm3OUV+/aNbcdfePQRSTopqCDFG0125BHIWyXYZ" .toCharArray();//字典内顺序任意更改，只要内容保证不缺就行 private static HashMap&lt;Character, Integer&gt; hashDecode = new HashMap&lt;Character, Integer&gt;(); /** * data[]进行编码 * * @param data * @return */ public static String encode(byte[] data) &#123; int start = 0; int len = data.length; StringBuffer buf = new StringBuffer(data.length * 3 / 2); int end = len - 3; int i = start; int n = 0; while (i &lt;= end) &#123; int d = ((((int) data[i]) &amp; 0x0ff) &lt;&lt; 16) | ((((int) data[i + 1]) &amp; 0x0ff) &lt;&lt; 8) | (((int) data[i + 2]) &amp; 0x0ff); buf.append(legalChars[(d &gt;&gt; 18) &amp; 63]); buf.append(legalChars[(d &gt;&gt; 12) &amp; 63]); buf.append(legalChars[(d &gt;&gt; 6) &amp; 63]); buf.append(legalChars[d &amp; 63]); i += 3; if (n++ &gt;= 14) &#123; n = 0; buf.append(" "); &#125; &#125; if (i == start + len - 2) &#123; int d = ((((int) data[i]) &amp; 0x0ff) &lt;&lt; 16) | ((((int) data[i + 1]) &amp; 255) &lt;&lt; 8); buf.append(legalChars[(d &gt;&gt; 18) &amp; 63]); buf.append(legalChars[(d &gt;&gt; 12) &amp; 63]); buf.append(legalChars[(d &gt;&gt; 6) &amp; 63]); buf.append("="); &#125; else if (i == start + len - 1) &#123; int d = (((int) data[i]) &amp; 0x0ff) &lt;&lt; 16; buf.append(legalChars[(d &gt;&gt; 18) &amp; 63]); buf.append(legalChars[(d &gt;&gt; 12) &amp; 63]); buf.append("=="); &#125; return buf.toString(); &#125; public static byte[] decode(String s) &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); try &#123; decode(s, bos); &#125; catch (IOException e) &#123; throw new RuntimeException(); &#125; byte[] decodedBytes = bos.toByteArray(); try &#123; bos.close(); bos = null; &#125; catch (IOException ex) &#123; System.err.println("Error while decoding BASE64: " + ex.toString()); &#125; return decodedBytes; &#125; private static void decode(String s, OutputStream os) throws IOException &#123; int i = 0; int len = s.length(); while (true) &#123; while (i &lt; len &amp;&amp; s.charAt(i) &lt;= ' ') &#123; i++; &#125; if (i == len) &#123; break; &#125; int tri = (decode(s.charAt(i)) &lt;&lt; 18) + (decode(s.charAt(i + 1)) &lt;&lt; 12) + (decode(s.charAt(i + 2)) &lt;&lt; 6) + (decode(s.charAt(i + 3))); os.write((tri &gt;&gt; 16) &amp; 255); if (s.charAt(i + 2) == '=') &#123; break; &#125; os.write((tri &gt;&gt; 8) &amp; 255); if (s.charAt(i + 3) == '=') &#123; break; &#125; os.write(tri &amp; 255); i += 4; &#125; &#125; private static int decode(char c) &#123; if (hashDecode.size() == 0) &#123; for (int i = 0; i &lt; 64; i++) &#123; char ch = legalChars[i]; hashDecode.put(ch, i); &#125; &#125; if (hashDecode.containsKey(c)) &#123; return hashDecode.get(c); &#125; else if (c == '=') &#123; return 0; &#125; else &#123; throw new RuntimeException("unexpected code: " + c); &#125; &#125; Des加密算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import javax.crypto.Cipher;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;/** * Create by wjup on 2019/7/1 9:12 */public class DateSecret &#123;// private static String keyCode = "12345678";//秘钥可以任意改，只要总长度是8个字节就行 private static byte[] iv = &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;; /** * 加密 * @param encryptString * @param keyCode 8位秘钥 * @return * @throws Exception */ public static String encryptDES(String encryptString,String keyCode) throws Exception &#123; IvParameterSpec zeroIv = new IvParameterSpec(iv); SecretKeySpec key = new SecretKeySpec(keyCode.getBytes(), "DES"); Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding"); cipher.init(Cipher.ENCRYPT_MODE, key, zeroIv); byte[] encryptedData = cipher.doFinal(encryptString.getBytes("utf-8")); return Base64.encode(encryptedData); &#125; /** * 解密 * @param decryptString * @param keyCode 8位秘钥 * @return * @throws Exception */ public static String decryptDES(String decryptString,String keyCode) throws Exception &#123; byte[] byteMi = Base64.decode(decryptString); IvParameterSpec zeroIv = new IvParameterSpec(iv); SecretKeySpec key = new SecretKeySpec(keyCode.getBytes(), "DES"); Cipher cipher = Cipher.getInstance("DES/CBC/PKCS5Padding"); cipher.init(Cipher.DECRYPT_MODE, key, zeroIv); byte decryptedData[] = cipher.doFinal(byteMi); return new String(decryptedData, "utf-8"); &#125; /** * 将二进制转换成16进制 * * @param buf * @return String */ public static String parseByte2HexStr(byte buf[]) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; buf.length; i++) &#123; String hex = Integer.toHexString(buf[i] &amp; 0xFF); if (hex.length() == 1) &#123; hex = '0' + hex; &#125; sb.append(hex.toUpperCase()); &#125; return sb.toString(); &#125; // 示例 public static void main(String[] args) &#123; try &#123; // 加密 String s = encryptDES("天王盖地虎","12345678"); // 解密 String s1 = decryptDES(s,"12345678"); System.out.println("加密后："+s+"\n解密后："+s1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 参考信息https://www.cnblogs.com/yanchaohui/p/11005037.htmlhttps://blog.csdn.net/f2006116/article/details/53222328]]></content>
      <categories>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>json加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有印象的书、动漫、电影、电视剧]]></title>
    <url>%2F2019%2F06%2F29%2F%E6%9C%89%E5%8D%B0%E8%B1%A1%E7%9A%84%E4%B9%A6%E3%80%81%E5%8A%A8%E6%BC%AB%E3%80%81%E7%94%B5%E5%BD%B1%E3%80%81%E7%94%B5%E8%A7%86%E5%89%A7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;“时光竟已走的这么匆忙，怎么刚刚学会懂事就老了，怎么刚刚学会包容就老了，怎么刚~~ 车辆行驶中，请站稳扶好，前方到站…”&emsp;&emsp;公交上的一首歌不知觉的把自己带入了这几年的回忆中，时间的确过得挺快。2009年仿佛还在昨天，然而已经过去十年了。长久不见的中年人见面也在感叹，一晃时间过得多快啊，看孩子们都工作到了谈婚论嫁的时候了。&emsp;&emsp;唉，岁月饶过谁，每天行尸走肉一般。不禁反问自己：我们终究是活了365天，还是活了1天，重复了364遍？&emsp;&emsp;言归正传，这篇文章的主题不是感叹时间，而是记录下我这些年读过和看过的自认为好的作品，一时之间可能有很多想不起来的。 &emsp;&emsp;首先电视剧是我们最早接触到的信息。小时候放学回到家，就打开电视机看动画片。爸妈们没少打骂我们“要赶紧写作业，少看电视，以后考个好大学，天天看都没人问”，不过那时哪里听得进去这些啊，于是不听就要被挨打，不过愈打愈看，愈看愈打。&emsp;&emsp;小时候能看到心爱的小鲤鱼泡泡打败赖皮蛇，挨点皮肉伤又算得了什么。后来实在扛不住打骂，就趁大人不在家偷看，等听到有开大门的声音，便迅雷不及掩耳之势拔掉电视机的插销，然而道高一尺魔高一丈。他们走到屋里摸摸电视机肚子，便认为你是看电视了，又少不了一顿“毒打”，任你怎么解释都不行。后来我还奇怪，怎么摸摸电视机肚子就知道我看电视了呢？还那么准，难道电视会说话？直到有一天我妈在外面和其他大人们肆意讨论他的战果时，我才知道这是他们之间广为流传的一个方法。就和电视机看着突然出雪花，只要你拍一下电视就好一样。同样看完电视，会残有余热，摸摸就知道你看没看。以至于后来每次偷看电视都会拿着扇子给电视扇风，怕它“热着”了。后来慢慢的长大，看的电视也越来越少，没机会也没时间了。 电视剧《鹿鼎记》 《仙剑奇侠传》 《白鹿原》 《人民的名义》 《毛骗》《权力的游戏》 《西部世界》 听说这两部不错还没看… 电影肖申克的救赎 当幸福来敲门 美丽人生 这个杀手不太冷 喊山 狼少年阿甘正传 第六感生死缘 绿皮书 调音师 模仿游戏 驴得水… 动漫画江湖之灵主 画江湖之不良人 少年锦衣卫 千与千寻 风少年 白蛇:缘起驯龙高手 寻梦环游记 风语咒 天上掉下个猪八戒 哆啦A梦 悬崖上的金鱼姬… 小说《活着》 《谁动了我的奶酪》… 未完待续…]]></content>
      <categories>
        <category>生活</category>
        <category>日常</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于消息队列相关]]></title>
    <url>%2F2019%2F06%2F26%2F%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;为什么使用消息队列？ 消息队列有什么优点和缺点？ Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么区别，以及适合哪些场景？ 面试问题：为什么使用消息队列啊？&emsp;&emsp;面试官心理分析，其实面试官主要是想看看： 第一，你知不知道你们系统里为什么要用消息队列这个东西？ 不少候选人，说自己项目里用了 Redis、MQ，但是其实他并不知道自己为什么要用这个东西。其实说白了，就是为了用而用，或者是别人设计的架构，他从头到尾都没思考过。 没有对自己的架构问过为什么的人，一定是平时没有思考的人，面试官对这类候选人印象通常很不好。因为面试官担心你进了团队之后只会木头木脑的干呆活儿，不会自己思考。 第二，你既然用了消息队列这个东西，你知不知道用了有什么好处&amp;坏处？ 你要是没考虑过这个，那你盲目弄个 MQ 进系统里，后面出了问题你是不是就自己溜了给公司留坑？你要是没考虑过引入一个技术可能存在的弊端和风险，面试官把这类候选人招进来了，基本可能就是挖坑型选手。就怕你干 1 年挖一堆坑，自己跳槽了，给公司留下无穷后患。 第三，既然你用了 MQ，可能是某一种 MQ，那么你当时做没做过调研？ 你别傻乎乎的自己拍脑袋看个人喜好就瞎用了一个 MQ，比如 Kafka，甚至都从没调研过业界流行的 MQ 到底有哪几种。每一个 MQ 的优点和缺点是什么。每一个 MQ 没有绝对的好坏，但是就是看用在哪个场景可以扬长避短，利用其优势，规避其劣势。 如果是一个不考虑技术选型的候选人招进了团队，leader 交给他一个任务，去设计个什么系统，他在里面用一些技术，可能都没考虑过选型，最后选的技术可能并不一定合适，一样是留坑。 面试题剖析 &emsp;&emsp;先说一下消息队列的常见使用场景吧，其实场景有很多，但是比较核心的有3个：解耦 异步 削峰 解耦&emsp;&emsp;现场画个图来说明一下 &emsp;&emsp;A系统发送个数据到BCD三个系统，接口调用发送，那如果E系统也要这个数据呢？那如果C系统现在不需要了呢？现在A系统又要发送第二种数据了呢？A系统负责人濒临崩溃中。。。再来点更加崩溃的事儿，A系统要时时刻刻考虑BCDE四个系统如果挂了咋办？我要不要重发？我要不要把消息存起来？头发都白了啊。。。 &emsp;&emsp;面试技巧：你需要去考虑一下你负责的系统中是否有类似的场景，就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。但是其实这个调用是不需要直接同步调用接口的，如果用MQ给他异步化解耦，也是可以的，你就需要去考虑在你的项目里，是不是可以运用这个MQ去进行系统的解耦。在简历中体现出来这块东西，用MQ作解耦。 异步&emsp;&emsp;现场画个图来说明一下， &emsp;&emsp;A系统接收一个请求，需要在自己本地写库，还需要在BCD三个系统写库，自己本地写库要3ms，BCD三个系统分别写库要300ms、450ms、200ms。最终请求总延时是3 + 300 + 450 + 200 = 953ms，接近1s，用户感觉搞个什么东西，慢死了慢死了。 削峰&emsp;&emsp;每天0点到11点，A系统风平浪静，每秒并发请求数量就100个。结果每次一到11点~1点，每秒并发请求数量突然会暴增到1万条。但是系统最大的处理能力就只能是每秒钟处理1000个请求啊。。。尴尬了，系统会死。。。 消息队列有什么优点和缺点啊？&emsp;&emsp;优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰&emsp;&emsp;缺点呢？显而易见的 系统可用性降低&emsp;&emsp;系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。 系统复杂性提高&emsp;&emsp;硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已 一致性问题&emsp;&emsp;A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。 &emsp;&emsp;所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，用，还是得用的。。。 kafka、activemq、rabbitmq、rocketmq都有什么优点和缺点啊？&emsp;&emsp;常见的MQ其实就这几种，别的还有很多其他MQ，但是比较冷门的，那么就别多说了&emsp;&emsp;作为一个码农，你起码得知道各种mq的优点和缺点吧，咱们来画个表格看看 特性 ActiveMQ RabbitMQ RocketMQ Kafka 单机吞吐量 万级，吞吐量比RocketMQ和Kafka要低了一个数量级 万级，吞吐量比RocketMQ和Kafka要低了一个数量级 10万级，RocketMQ也是可以支撑高吞吐的一种MQ 10万级别，这是kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景 topic数量对吞吐量的影响 topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降。这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic topic从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源 时效性 ms级 微秒级，这是rabbitmq的一大特点，延迟是最低的 ms级 延迟在ms级以内 可用性 高，基于主从架构实现高可用性 高，基于主从架构实现高可用性 非常高，分布式架构 非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 消息可靠性 有较低的概率丢失数据 经过参数优化配置，可以做到0丢失 经过参数优化配置，消息可以做到0丢失 功能支持 MQ领域的功能极其完备 基于erlang开发，所以并发能力很强，性能极其好，延时很低 MQ功能较为完善，还是分布式的，扩展性好 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 优劣势总结 非常成熟，功能强大，在业内大量的公司以及项目中都有应用偶尔会有较低概率丢失消息而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 erlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备而且开源提供的管理界面非常棒，用起来很好用社区相对比较活跃，几乎每个月都发布几个版本分在国内一些互联网公司近几年用rabbitmq也比较多一些但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。 接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的 kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集 再来张图图看看 &emsp;&emsp;综上所述，各种对比之后，我个人倾向于是： &emsp;&emsp;一般的业务系统要引入MQ，最早大家都用ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了； &emsp;&emsp;后来大家开始用RabbitMQ，但是确实erlang语言阻止了大量的java工程师去深入研究和掌控他，对公司而言，几乎处于不可控的状态，但是确实人是开源的，比较稳定的支持，活跃度也高； &emsp;&emsp;不过现在确实越来越多的公司，会去用RocketMQ，确实很不错，但是我提醒一下自己想好社区万一突然黄掉的风险，对自己公司技术实力有绝对自信的，我推荐用RocketMQ，否则回去老老实实用RabbitMQ吧，人是活跃开源社区，绝对不会黄 &emsp;&emsp;所以中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择 &emsp;&emsp;如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范 参考：https://studygolang.com/topics/8246#reply0https://blog.csdn.net/u014801403/article/details/80308353]]></content>
      <categories>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周末博物馆一日游]]></title>
    <url>%2F2019%2F06%2F25%2F%E5%91%A8%E6%9C%AB%E5%8D%9A%E7%89%A9%E9%A6%86%E4%B8%80%E6%97%A5%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[上周六，在家呆着无聊，于是被女朋友胁迫着出去玩，商量之后选择了先去博物馆参观一下。说走就走，先秀一波…拍照技术 烈日炎炎终于到了博物馆，刷身份证进去后，映入眼帘的是大大的大厅，顶部是一个大铜钱的样式，体现了博物馆文物、收藏的核心理念 一楼展览厅则是“重量级”的文物，包括佛像、建筑等等 二楼则是一些书画等。三楼大多是标本类的。 当然下面这些可不是人体标本（僵尸？），据我观察可能是蜡像 整个展览厅数人最多的应该是这里了，《非洲野生动物大迁徙》主题馆，动物种类非常多，也很逼真，只是拍出来像拍的一幅画一样，没有立体感 当然这时候也不忘留个念 整个二楼还没逛完，就已经过去两三个小时了，二楼还没逛完（1-&gt;3-&gt;2）,就离开了。回家？不可能！去了人山人海的芙蓉街]]></content>
      <categories>
        <category>生活</category>
        <category>游记</category>
      </categories>
      <tags>
        <tag>博物馆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lombok包的介绍]]></title>
    <url>%2F2019%2F06%2F23%2Flombok%E5%8C%85%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[lombok官方下载地址：https://projectlombok.org/downloadlombok的maven与引用：https://mvnrepository.com/artifact/org.projectlombok/lombok 功能介绍lombok可以通过注解的形式，在在编译时自动为实体类属性生成构造器、getter/setter、equals、hashcode、toString方法。非常便捷，而且实体类java文件中还不会长长的get/set代码，显得很简洁。 使用方法编辑器使用，先安装lombok插件，maven中引用lombok的jar包 注解解释@Data@Data注解在类上，会为所有属性自动生成setter/getter、equals、canEqual、hashCode、toString方法。如果属性为final修饰，则不会为该属性生成setter方法。 示例1234567891011import java.io.Serializable;import lombok.Data;@Data public class DataExample implements Serializable&#123; private final String name; private int age; private double score; private String[] tags;&#125; @Getter/@Setter@Getter/@Setter注解在属性上，可以为属性生成get/set方法 示例1234567891011121314import java.io.Serializable;import lombok.Getter;import lombok.Setter;public class DataExample implements Serializable&#123; private final String name; @Getter @Setter private int age; private double score; private String[] tags;&#125; @ToString@ToString注解在类上，Lombok会生成一个toString()方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割。也可以设置不包含哪些字段，如：@ToString(exclude = {“age”,”name”}) 示例1234567891011import java.io.Serializable;import lombok.ToString;@ToString public class DataExample implements Serializable&#123; private final String name; private int age; private double score; private String[] tags;&#125; @NoArgsConstructor/@RequiredArgsConstructor/@AllArgsConstructor@NoArgsConstructor/@RequiredArgsConstructor/@AllArgsConstructor注解在类上，分别可以实现无参构造器/部分参数构造器（为所有 final 和 @NonNull 修饰的字段生成一个构造方法）/全参构造器。 示例12345678910111213import java.io.Serializable;import lombok.AllArgsConstructor;import lombok.NoArgsConstructor;@AllArgsConstructor@NoArgsConstructorpublic class DataExample implements Serializable&#123; private final String name; private int age; private double score; private String[] tags;&#125; @Accessors(chain = true)@Accessors(chain = true)在类上使用，可以设置对象属性时接连链式设置，比如person,setName(“tom”).setAge(18).setSex(“boy”)…. 示例1234567891011import java.io.Serializable;import lombok.experimental.Accessors;@Accessors(chain = true)public class DataExample implements Serializable&#123; private final String name; private int age; private double score; private String[] tags;&#125; 总结优点 能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率 让代码变得简洁，不用过多的去关注相应的方法 属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等 缺点 不支持多种参数构造器的重载虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度 不支持多种参数构造器的重载虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度 AllLombok虽然有很多优点，但Lombok更类似于一种IDE插件，项目也需要依赖相应的jar包。Lombok依赖jar包是因为编译时要用它的注解，为什么说它又类似插件？因为在使用时，eclipse或IntelliJ IDEA都需要安装相应的插件，在编译器编译时通过操作AST（抽象语法树）改变字节码生成，变向的就是说它在改变java语法。它不像spring的依赖注入或者mybatis的ORM一样是运行时的特性，而是编译时的特性。这里我个人最感觉不爽的地方就是对插件的依赖！因为Lombok只是省去了一些人工生成代码的麻烦，但IDE都有快捷键来协助生成getter/setter等方法，也非常方便。 知乎上有位大神发表过对Lombok的一些看法： 这是一种低级趣味的插件，不建议使用。JAVA发展到今天，各种插件层出不穷，如何甄别各种插件的优劣？能从架构上优化你的设计的，能提高应用程序性能的 ，实现高度封装可扩展的…， 像lombok这种，像这种插件，已经不仅仅是插件了，改变了你如何编写源码，事实上，少去了代码你写上去又如何？如果JAVA家族到处充斥这样的东西，那只不过是一坨披着金属颜色的屎，迟早会被其它的语言取代。 虽然话糙但理确实不糙，试想一个项目有非常多类似Lombok这样的插件，个人觉得真的会极大的降低阅读源代码的舒适度。 虽然非常不建议在属性的getter/setter写一些业务代码，但在多年项目的实战中，有时通过给getter/setter加一点点业务代码，能极大的简化某些业务场景的代码。所谓取舍，也许就是这时的舍弃一定的规范，取得极大的方便。 我现在非常坚信一条理念，任何编程语言或插件，都仅仅只是工具而已，即使工具再强大也在于用的人，就如同小米加步枪照样能赢飞机大炮的道理一样。结合具体业务场景和项目实际情况，无需一味追求高大上的技术，适合的才是王道。 Lombok有它的得天独厚的优点，也有它避之不及的缺点，熟知其优缺点，在实战中灵活运用才是王道。 参考：https://www.cnblogs.com/heyonggang/p/8638374.htmlhttps://projectlombok.org/features/https://github.com/rzwitserloot/lombok?spm=a2c4e.11153940.blogcont59972.5.2aeb6d32hayLHvhttps://www.zhihu.com/question/42348457https://blog.csdn.net/ghsau/article/details/52334762]]></content>
      <categories>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《致橡树》]]></title>
    <url>%2F2019%2F06%2F21%2F%E3%80%8A%E8%87%B4%E6%A9%A1%E6%A0%91%E3%80%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;最初了解到这首诗，还是在网络剧《春风十里不如你》里秋水朗诵给小红听的。这个电视剧也陪伴了我刚出大学实习的整个夏天，每当听到主题曲《如果我爱你》，都会陷入满满的回忆中，这就叫应景生情吧。而里面朗诵的《致橡树》也不止一次出现。 作者简介 舒婷，原名龚佩瑜，女，汉族，1952年5月生，福建晋江人。 中国当代女诗人，朦胧诗派的代表人物。从小随父母定居于厦门，1969年下乡插队，1972年返城当工人，1979年开始发表诗歌作品，1980年至福建省文联工作，从事专业写作。 下面让我们一块欣赏由舒婷写带来的这首《致橡树》吧 我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己；我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲；也不止像泉源，常年送来清凉的慰藉；也不止像险峰，增加你的高度，衬托你的威仪。甚至日光，甚至春雨。不，这些都还不够！我必须是你近旁的一株木棉，作为树的形象和你站在一起。根，紧握在地下；叶，相触在云里。每一阵风过，我们都互相致意，但没有人，听懂我们的言语。你有你的铜枝铁干，像刀，像剑，也像戟；我有我红硕的花朵，像沉重的叹息，又像英勇的火炬。我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。仿佛永远分离，却又终身相依。这才是伟大的爱情，坚贞就在这里：爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson生成各种格式json串]]></title>
    <url>%2F2019%2F06%2F21%2Ffastjson%E7%94%9F%E6%88%90%E5%90%84%E7%A7%8D%E6%A0%BC%E5%BC%8Fjson%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[本文json的jar包，采用阿里云的fastjson官方github下载地址：https://github.com/alibaba/fastjson 样式一：json对象1234&#123; "xxx": "xxx", "yyy": "yyy"&#125; 代码实现示例 12345JSONObject json = new JSONObject();json.put("xxx","xxxx");json.put("yyy","yyy");String str = json.toJSONString();// &#123;"xxx":"xxx"&#125;; ###样式二：json数组包含对象 1234567[&#123; "xx": "xx", "yy": "yy"&#125;, &#123; "xx": "yy", "yy": "yy"&#125;] 代码实现示例 1234567891011String[] key = &#123;"张三","李四","王五","田七"&#125;int[] value = &#123;32,23,33,36&#125;JSONArray jsonArray = new JSONArray(); for (int i = 0; i &lt; keyName.length; i++) &#123; JSONObject jsonObj = new JSONObject(); jsonObj.put("name",key[i]); jsonObj.put("age",value[i]); jsonArray.add(jsonObj); &#125;String str = jsonArray.toJSONString();// [&#123;"name":"张三","age":32&#125;,&#123;"name":"李四","age":23&#125;...] 样式三：json对象包含数组12345678&#123; "name": "xxx", "interfaces": [&#123; "name": "yyy", "untagged": true &#125;], "remark": "xxxxx"&#125; 代码实现示例 1234567891011121314JSONObject json = new JSONObject();json.put("name","vlan_apitest");JSONObject inter = new JSONObject();inter.put("name","1.2");inter.put("untagged",true);JSONArray jsonArr = new JSONArray();jsonArr.add(inter);json.put("interfaces",jsonArr);json.put("remark",666);String str = json.toJSONString();// &#123;"interfaces":[&#123;"untagged":true,"name":"1.2"&#125;],"name":"vlan_apitest","remark":666&#125; 本想整理所有有可能出现的样式，写完这几个才发现很简单，也没啥必要继续整理了，就这样吧！]]></content>
      <categories>
        <category>编程</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[没时间解释了快上船]]></title>
    <url>%2F2019%2F06%2F20%2F%E6%B2%A1%E6%97%B6%E9%97%B4%E8%A7%A3%E9%87%8A%E4%BA%86%E5%BF%AB%E4%B8%8A%E8%88%B9%2F</url>
    <content type="text"><![CDATA[没时间解释了，快上船 Your name is ready to fly with the Mars 2020 rover!]]></content>
      <categories>
        <category>生活</category>
        <category>日常</category>
      </categories>
      <tags>
        <tag>火星</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux基本常用命令笔记]]></title>
    <url>%2F2019%2F06%2F14%2Flinux%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[总结的常用的基础的linux命令 常用命令Linux 关闭终端运行python脚本(日志文件在统计目录中)：nohup python -u main.py &gt; test.out 2&gt;&amp;1 &amp;查看被占用的端口号：netstat -anp |grep 端口号查看所有端口号详情：netstat -nultp创建文件、文件夹：touch 文件名,mkdir 文件夹名解压：tar -xzvf sysconfig.tar.gz查看磁盘目录占用信息：df -h查看进程信息：ps -aux --sort -rss查看内存cpu使用信息：free -h进程显示–搜索进程：ps -ef|grep xxx杀死进程：kill -9 num搜索文件里信息（-n显示行数）：grep -n &quot;xxx&quot; xxx.log显示日志文件增长的信息：tail -f xx.log显示后几行信息：tail -n num **.log显示目录下名称带xx的文件：ls &quot;*xxx*&quot; liunx中安装软件教程linux安装java：https://www.cnblogs.com/lamp01/p/8932740.htmllinux安装mysql：https://www.cnblogs.com/daemon-/p/9009360.htmllinux安装redis：https://blog.csdn.net/qq_30764991/article/details/81564652linux安装nginx：https://blog.csdn.net/t8116189520/article/details/81909574（http://nginx.org/download/）linux安装python：https://www.cnblogs.com/yhongji/p/9383857.html]]></content>
      <categories>
        <category>编程</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置文件说明（包含黑名单、代理反射、负载均衡）]]></title>
    <url>%2F2019%2F06%2F14%2Fnginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[nginx.conf配置文件的注解，包含ip黑名单、负载均衡、代理反射 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218#运行用户 主模块指令，指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行user nobody;#启动进程,每个Nginx进程平均耗费10M~12M内存，通常建议设置成和cpu的数量相等worker_processes 1; #error_log是个主模块指令，用来定义全局错误日志文件。# 日志输出级别有debug、info、notice、warn、error、crit可供选择# 其中debug输出日志最为最详细，而crit输出日志最少。error_log logs/error.log;# error_log logs/error.log notice;# error_log logs/error.log info; # pid是个主模块指令，用来指定进程pid的存储文件位置pid logs/nginx.pid; #工作模式及连接数上限events &#123; #epoll是多路复用IO(I/O Multiplexing)中的一种方式, #仅用于linux2.6以上内核,可以大大提高nginx的性能 use epoll; #单个后台worker process进程的最大并发链接数 worker_connections 1024; # 并发总数是 worker_processes 和 worker_connections 的乘积 # 即 max_clients = worker_processes * worker_connections # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4 为什么 # 为什么上面反向代理要除以4，应该说是一个经验值 # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000 # worker_connections 值的设置跟物理内存大小有关 # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数 # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右 # 我们来看看360M内存的VPS可以打开的文件句柄数是多少： # $ cat /proc/sys/fs/file-max # 输出 34336 # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内 # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置 # 使得并发总数小于操作系统可以打开的最大文件数目 # 其实质也就是根据主机的物理CPU和内存进行配置 # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。 # ulimit -SHn 65535 &#125; http &#123; #设定mime类型,类型由mime.type文件定义 include mime.types; default_type application/octet-stream; #设定日志格式 log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log logs/access.log main; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件， #对于普通应用，必须设为 on, #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off， #以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; tcp_nodelay on; # 开启gzip压缩 gzip on; gzip_disable &quot;MSIE [1-6].&quot;; # 设定请求缓冲 client_header_buffer_size 128k; large_client_header_buffers 4 128k; # ip黑名单 # 在Nginx的conf目录下面建立blockip.conf文件（名称可以随意）然后引入 # 单个网站屏蔽IP的方法：把include blocksip.conf;放到网址对应的在server &#123;&#125;语句块； # 多个网站屏蔽IP的方法：把include blocksip.conf;放到http &#123;&#125;语句块。 # include blockip.conf; # 文件里的格式如下 # 屏蔽单个ip访问：deny IP; # 允许单个ip访问：allow IP; # 屏蔽所有ip访问：deny all; # 允许所有ip访问：allow all; # 屏蔽整个段：从123.0.0.1到123.255.255.254 ## deny 123.0.0.0/8; # 屏蔽IP段：从123.45.0.1到123.45.255.254 ## deny 123.45.0.0/16; # 屏蔽IP段：从123.45.6.1到123.45.6.254 ## deny 123.45.6.0/24; # 除了几个IP外，其他全部拒绝 ## allow 1.1.1.1; ## allow 1.1.1.2; ## deny all; # 设定虚拟主机配置 server &#123; # 侦听80端口 listen 80; # 定义使用 www.nginx.cn访问，多个域名之间用空格分开 server_name www.nginx.cn; # 设定本虚拟主机的访问日志 access_log logs/nginx.access.log main; # 默认请求 # location： 表示url匹配，/表示全部匹。 location / &#123; #定义服务器的默认网站根目录位置（html和config同级目录） # 可自定义目录如 root /home/html root html; #定义首页索引文件的名称 index index.php index.html index.htm; &#125; # 定义错误提示页面 # 特别需要注意的是，这些错误信息的返回页面大小一定要超过512K，否者会被ie浏览器替换为ie默认的错误页面 error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; #静态文件，nginx自己处理 location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123; #过期30天，静态文件不怎么更新，过期可以设大一点， #如果频繁更新，则可以设置得小一点。 expires 30d; &#125; # 这段设置是将upload和html下的所有文件都交给nginx来处理 # 当然，upload和html目录包含在/web/wwwroot/xx目录中。 location ~ ^/(upload|html)/ &#123; root /web/wwwroot/xx; expires 30d; &#125; #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置. location ~ .php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; #禁止访问 .txt/doc 文件 location ~* \.(txt|doc)$ &#123; root /usr/local/nginx/html; deny all; &#125; &#125; # 反向代理实现负载均衡 # 准确的来说，这属于：HTTP重定向实现负载均衡。它有一个比较大的缺点 # 由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。 # 而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡， # 只不过是把请求次数平均分配给每台服务器罢了。但是它确实实现了负载均衡， # 在一些要去并不强烈的项目中可以使用http重定向来实现均衡每台服务器压力的效果，以达到更高的并发总量。 upstream tom3 &#123; # 采用源地址哈希法进行分配() # 对访问用户的IP进行hash后的结果进行分配，这样每一个用户固定请求同一个后端服务器，能够解决session的问题。 # ip_hash; # weight 默认为1，weight值越大，负载的权重就越大，访问概率越大 # server localhost:1996 weight=1; # down 表示当前的server暂时不参与负载 # server localhost:1996 down; # backup 表示其它所有的非backup机器down或者忙的时候，请求backup机器 # server localhost:1996 backup; server localhost:1996; server localhost:1997; server localhost:1998; &#125; # 反向代理 server &#123; listen 80; server_name www.nginx2.cn; location / &#123; # 会转发到设置的三台tomcat上 proxy_pass http://tom3; # nginx向tomcat发起连接，即第一次握手等待tomcat回应的超时时间，tomcat的这次回应只是说明能正常连接，并没有响应具体请求的内容。 # 如果其中有台tomcat故障，3秒后转移到其他tomcat上，默认时间是60秒 proxy_connect_timeout 3s; # tomcat接受到真正业务请求之后，nginx等待tomcat响应具体请求内容的超时时间。 # 差不多可以理解tomcat处理具体请求时间的最大值，也就是tomcat必须在这个时间内做完业务逻辑处理。 proxy_read_timeout 20s; # nginx将请求发送给tomcat的超时时间，应该是确认能正常连接之后向tomcat发送真正的业务请求。 proxy_send_timeout 3s; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; &#125;]]></content>
      <categories>
        <category>编程</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx禁止直接访问目录或文件]]></title>
    <url>%2F2019%2F06%2F13%2Fnginx%E7%A6%81%E6%AD%A2%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;nginx禁止直接访问目录或文件，如果不禁止，nginx会直接去下载web目录下文件，如果有配置文件，并可以直接暴露一些配置文件源代码。测试时要清理浏览器缓存，浏览器会缓存下载的文件。如果有类似配置文件，建议不要放在web目录下，会更加安全。 禁止访问某些后缀文件123location ~ \.(ini|conf|txt)$ &#123; deny all;&#125; 禁止访问目录或目录下文件123456789# 禁止访问目录location ^~ /test/ &#123; deny all;&#125;# 禁止访问目录下文件location ^~ /test &#123; deny all;&#125; nginx location 匹配相关= 表示精确匹配 ^~ 表示uri以某个字符串开头 ~ 正则匹配(区分大小写) ~* 正则匹配(不区分大小写) !~和!~*分别为区分大小写不匹配及不区分大小写不匹配的正则 / 任何请求都会匹配 匹配优先级： = &gt; ^~ &gt; / 转发自：PHP自学网]]></content>
      <categories>
        <category>编程</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx配置ip黑名单和限制ip请求次数]]></title>
    <url>%2F2019%2F05%2F23%2Fnginx%E9%85%8D%E7%BD%AEip%E9%BB%91%E5%90%8D%E5%8D%95%E5%92%8C%E9%99%90%E5%88%B6ip%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[nginx黑名单设置在nginx/conf下创建黑名单文件ip.black（叫啥都行）在文件内容写上列入黑名单的IP，格式为deny IP例如：deny 192.168.66.88; 在nginx.conf进行配置引入配置的文件123456http &#123; include mime.types; # 黑名单 include ip.black; default_type application/octet-stream; 设置后当黑名单中的ip再来访问时就会出现403拒绝访问页面了 HttpLimitReqModul 限制某一段时间内同一ip访问数实例123456789101112131415161718192021222324252627282930http&#123; #定义一个名为allips的limit_req_zone用来存储session，大小是10M内存， #以$binary_remote_addr 为key,限制平均每秒的请求为20个， #1M能存储16000个状态，rete的值必须为整数， #如果限制两秒钟一个请求，可以设置成30r/m limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s; server&#123; location &#123; #限制每ip每秒不超过20个请求，漏桶数burst为5 #brust的意思就是，如果第1秒、2,3,4秒请求为19个， #第5秒的请求为25个是被允许的。 #但是如果你第1秒就25个请求，第2秒超过20的请求返回503错误。 #nodelay，如果不设置该选项，严格使用平均速率限制请求数， #第1秒25个请求时，5个请求放到第2秒执行， #设置nodelay，25个请求将在第1秒执行。 limit_req zone=allips burst=5 nodelay; &#125; &#125;&#125; HttpLimitZoneModule 限制并发连接数实例limit_zone只能定义在http作用域，limit_conn可以定义在http server location作用域12345678910111213141516171819202122http&#123; #定义一个名为one的limit_zone,大小10M内存来存储session， #以$binary_remote_addr 为key #nginx 1.18以后用limit_conn_zone替换了limit_conn #且只能放在http作用域 limit_conn_zone one $binary_remote_addr 10m; server&#123; location &#123; limit_conn one 20; #连接数限制 #带宽限制,对单个连接限数，如果一个ip两个连接，就是500x2k limit_rate 500k; &#125; &#125;&#125; nginx白名单设置以上配置会对所有的ip都进行限制，有些时候我们不希望对搜索引擎的蜘蛛或者自己测试ip进行限制，对于特定的白名单ip我们可以借助geo指令实现。1.123456789101112131415161718192021222324252627282930313233http&#123; geo $limited&#123; default 1; #google 64.233.160.0/19 0; 65.52.0.0/14 0; 66.102.0.0/20 0; 66.249.64.0/19 0; 72.14.192.0/18 0; 74.125.0.0/16 0; 209.85.128.0/17 0; 216.239.32.0/19 0; #M$ 64.4.0.0/18 0; 157.60.0.0/16 0; 157.54.0.0/15 0; 157.56.0.0/14 0; 207.46.0.0/16 0; 207.68.192.0/20 0; 207.68.128.0/18 0; #yahoo 8.12.144.0/24 0; 66.196.64.0/18 0; 66.228.160.0/19 0; 67.195.0.0/16 0; 74.6.0.0/16 0; 68.142.192.0/18 0; 72.30.0.0/16 0; 209.191.64.0/18 0; #My IPs 127.0.0.1/32 0; 123.456.0.0/28 0; #example for your server CIDR &#125; geo指令定义了一个白名单$limited变量，默认值为1，如果客户端ip在上面的范围内，$limited的值为0 2.使用map指令映射搜索引擎客户端的ip为空串，如果不是搜索引擎就显示本身真是的ip，这样搜索引擎ip就不能存到limit_req_zone内存session中，所以不会限制搜索引擎的ip访问1234map $limited $limit &#123;1 $binary_remote_addr;0 "";&#125; 3.设置limit_req_zone和limit_reqlimit_req_zone $limit zone=foo:1m rate=10r/m; limit_req zone=foo burst=5; 最后我们使用ab压php-fpm的方式，对上面的方法效果实际测试下 例1：限制只允许一分钟内只允许一个ip访问60次配置，也就是平均每秒1次首先我们准备一个php脚本放在根目录下$document_roottest.php nginx配置增加limit_req_zone 和 limit_req123456789101112131415http&#123; limit_req_zone $binary_remote_addr zone=allips:10m rate=60r/m; server&#123; location &#123; limit_req zone=allips; &#125; &#125;&#125; ab -n 5 -c 1 http://www.weizhang.org/test.php 118.144.94.193 - - [22/Dec/2012:06:27:06 +0000] “GET /test.php HTTP/1.0” 200 11000 “-“ “ApacheBench/2.3”118.144.94.193 - - [22/Dec/2012:06:27:06 +0000] “GET /test.php HTTP/1.0” 503 537 “-“ “ApacheBench/2.3”118.144.94.193 - - [22/Dec/2012:06:27:07 +0000] “GET /test.php HTTP/1.0” 503 537 “-“ “ApacheBench/2.3”118.144.94.193 - - [22/Dec/2012:06:27:07 +0000] “GET /test.php HTTP/1.0” 503 537 “-“ “ApacheBench/2.3”118.144.94.193 - - [22/Dec/2012:06:27:07 +0000] “GET /test.php HTTP/1.0” 503 537 “-“ “ApacheBench/2.3” 未设置brust和nodelay可以看到该配置只允许每秒访问1次，超出的请求返回503错误123456789101112131415http&#123; limit_req_zone $binary_remote_addr zone=allips:10m rate=60r/m; server&#123; location &#123; limit_req zone=allips burst=1 nodelay; &#125; &#125;&#125; ab -n 5 -c 1 http://www.weizhang.org/test.php 118.144.94.193 - - [22/Dec/2012:07:01:00 +0000] “GET /test.php HTTP/1.0” 200 11000 “-“ “ApacheBench/2.3”118.144.94.193 - - [22/Dec/2012:07:01:00 +0000] “GET /test.php HTTP/1.0” 200 11000 “-“ “ApacheBench/2.3”118.144.94.193 - - [22/Dec/2012:07:01:01 +0000] “GET /test.php HTTP/1.0” 503 537 “-“ “ApacheBench/2.3”118.144.94.193 - - [22/Dec/2012:07:01:01 +0000] “GET /test.php HTTP/1.0” 503 537 “-“ “ApacheBench/2.3”118.144.94.193 - - [22/Dec/2012:07:01:01 +0000] “GET /test.php HTTP/1.0” 503 537 “-“ “ApacheBench/2.3” 设置brust=1和nodelay后允许第1秒处理两个请求。]]></content>
      <categories>
        <category>编程</category>
        <category>hginx</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3编写贴吧图片下载软件]]></title>
    <url>%2F2019%2F05%2F23%2Fpython3%E7%BC%96%E5%86%99%E8%B4%B4%E5%90%A7%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[刚开始了解python爬虫写的，代码都很简单。我的CSDN原文地址：python 3 爬取某小说网站小说，注释详细先上效果图，启动后是这样的： 按提示输入内容运行后是这样的： 上代码（基本都是最基本的语法，不多解释了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import requestsimport osfrom bs4 import BeautifulSoupfrom pip._vendor.distlib.compat import raw_input def down(type, num, url, img_path): if type == '1': url2 = url + '&amp;pn=&#123;&#125;'.format(num) else: url2 = url + '?pn=&#123;&#125;'.format(num) # 如果不存在此文件夹就创建 if not os.path.exists(img_path): os.makedirs(img_path) # 解析地址 req = requests.get(url2) # 设置编码，浏览器查看网站编码：F12，控制开输入document.characterSet回车即可查看 req.encoding = "utf-8" # 获取网页所有内容 bs = BeautifulSoup(req.text, 'html.parser') # 找到类名为BDE_Image的标签 img = bs(class_='BDE_Image') con = 0 if img.__len__() == 0: print("&lt;--第&#123;&#125;页无图片，跳转下一页--&gt;".format(num)) else: for xx in img: con += 1 # 获取图片地址、图片宽高 url = xx.get('src') height = xx.get('height') width = xx.get('width') name = '\\' + str(num) + '_' + str(con) + '(' + height + 'x' + width + ')' # 下载 res = requests.get(url) with open("&#123;&#125;&#123;&#125;&#123;&#125;".format(img_path, name, '.jpg'), 'wb')as f: f.write(res.content) print("第&#123;&#125;页，第&#123;&#125;张，下载完毕".format(num, con)) if __name__ == '__main__': print('贴吧图片下载工具v1.0 by wjup\n\n说明：输入内容请按要求填写，填错会退出程序。' '\n请规范输入帖子地址,像这样--&gt;\n只看楼主：https://tieba.baidu.com/p/3430697608?see_lz=1\n' '不是只看楼主：https://tieba.baidu.com/p/3430697608' '\n图片保存路径写法：F:\\\image，如果不填会默认下载到E:\\\贴吧图片 目录下\n\n') type = raw_input('开始吧！\n\n请选择是否为只看楼主类型的地址\n（输入1或2即可） 1：是 2：否 :') while type.strip() == '': type = raw_input('请选择是否为只看楼主类型的地址\n（输入1或2即可） 1：是 2：否 :') url = raw_input('\n请输入贴子地址:') while url.strip() == '': print('地址都不输入，还下载个毛！') url = raw_input('请输入贴子地址:') end_page = input('\n请输入帖子总页数：') if end_page.strip() == '': print('页数为空，默认下载前3页图片内容') end_page = 3 img_path = raw_input('\n请输入图片保存路径（例：F:\\\image）：') print('-------------下载--------------') if not img_path.strip(): print('地址为空默认保存到 E:\\\贴吧图片') print('-------------下载--------------\n') img_path = 'E:\\贴吧图片' for i in range(1, int(end_page) + 1): down(type, i, url, img_path)]]></content>
      <categories>
        <category>编程</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新服务器简单配置]]></title>
    <url>%2F2019%2F05%2F23%2F%E6%96%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[今早翻开手机看到某云一条广告Linux1 核 2 GB 1 Mbps服务器10元一个月，正巧最近在搞linux，于是下单了一台2个月20。 上班来到公司后，借空闲时间一顿研究，一波骚操作配置后，浏览器打开ip地址正常，看到了熟悉的tomcat9页面。 然后又是一波骚操作，把自己的之前写的spring boot + jpa + bootstrap + thymeleaf 简单的增删改查Demo项目部署了上去，打开ip也正常显示。 所以在此记录下，当拿到一台全新的linux服务器后该如何配置（操作步骤借鉴公司内部的环境部署文档） 我的配置流程是：网络设置、mysql、java、tomcat、发布项目 配置网络设置有的linux拿到后不能访问网络所以要配置下网络设置vi /etc/resolv.conf：添加一行 nameserver 114.114.114.114 重启网络：service network restart 配置mysql安装mysql：yum –y install mysql 在这里安装后可能会出现一个错误，解决如下：yum install的时候提示：Loaded plugins: fastestmirrorfastestmirror是yum的一个加速插件，这里是插件提示信息是插件不能用了。不能用就先别用呗，禁用掉，先yum了再说。修改插件的配置文件vi /etc/yum/pluginconf.d/fastestmirror.confenabled = 1//由1改为0，禁用该插件修改yum的配置文件vi /etc/yum.confplugins=1//改为0，不使用插件 安装mariadb（mysql的分支）：yum -y install mariadb-server 装库成功后启动数据库： systemctl start mariadb检查数据库状态： systemctl status mariadb 确保是开启状态后进入数据库：mysql为root账号设置密码，同时刷新权限，如密码是‘root’： use mysql;update user set Password=PASSWORD(&quot;root&quot;) where User=&#39;root&#39;;flush privileges; 增加一个用户。在项目中用它，创建用户名‘xxx’，密码‘123456a?’的用户 create user &#39;xxx&#39;@&#39;%&#39; identified by &#39;123456a?&#39;; 给他赋予所有的权限 GRANT ALL PRIVILEGES ON *.* TO &#39;xxx&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456a?&#39;; 刷新权限：flush privileges; 退出数据库，重新使用wjup和root账号登录，验证是否能登陆成功 这里也容易出现的问题：ERROR 1045 (28000): Access denied for user ‘tester‘@’localhost’ (using password: YES)解决方式a：用户密码是否正确，修改密码修改MySQL的登录设置：vim /etc/my.cnf在[mysqld]的段中加上一句：skip-grant-tables重新启动mysql// service mysql restartsystemctl restart mariadb登录并修改MySQL的root密码 mysql&gt; use mysql; Database changed mysql&gt; update user set password = password (‘new-password’) where user = ‘root’; Query OK, 0 rows affected (0.00 sec) Rows matched: 5 Changed: 0 Warnings: 0 mysql&gt; flush privileges; Query OK, 0 rows affected (0.01 sec) mysql&gt; quit将MySQL的登录设置修改回来vim /etc/my.cnf将刚才在[mysqld]的段中加上的skip-grant-tables注释保存并且退出vim重新启动mysql//service mysql restartsystemctl restart mariadb解决方式b：数据库中存在匿名用户，删除匿名用户即可Delete FROM user Where User=&#39;&#39;;flush privileges; 到这里如果需要远程连接，可以开放3306端口 iptables -I INPUT -p tcp --dport 3306 -j ACCEPT; 然后可以远程用navicat或者啥连接试试了 配置JDK我把jdk放在了/usr/java下 创建文件夹：mkdir /usr/java 用ftp工具上传下载好的jdk-8u211-linux-x64.rpm ORACLE官方下载地址 执行安装命令：rpm -ivh jdk-8u211-linux-x64.rpm 如果提示缺少执行权限执行权限命令：chmod +x jdk-8u211-linux-x64.rpm 查看java的版本信息：java -version 配置环境变量：vim ~/.bash_profile 末尾追加1234export JAVA_HOME=/usr/java/jdk1.8.0_211-amd64export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH 加载刚设置的变量：source /etc/profile 配置tomcattomcat同样我也放在了/usr/tomcat同样先创建文件夹：mkdir/tomcat用ftp工具上传进去，然后解压：tar -xzvf apache-tomcat-9.0.20.tar.gz tomcat官方下载地址 解压后编辑tomcat的配置文件，修改默认的8080端口改为80vi usr/tomcat/apache-tomcat-9.0.20/conf/server.xml 然后退出，保存（esc、:wq）,接着去tomcat的bin目录启动tomcat就可以了sh apache-tomcat-9.0.20/bin/startup.sh可以到tomcat的logs下查看catalina.outtail -f apache-tomcat-9.0.20/logs/catalina.out成功后放开80端口iptables -I INPUT -p tcp --dport 80 -j ACCEPT没问题的话然后在浏览器就可以看到tomcat9的默认页面了 发布项目 将项目配置好数据库连接信息和端口后打成war包，然后上传到tomcat的webapp目录下 先停止tomcat（sh shutdown.sh），再次启动即可（sh startup.sh） 等待启动成功后就可以在浏览器查看项目了（http://ip/war包名） 想访问地址不加war包名就可以可看到项目，可以把webapp下自动解压的war包文件夹里的内容替换到ROOT文件夹下即可]]></content>
      <categories>
        <category>编程</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>服务器配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五月周结🙃]]></title>
    <url>%2F2019%2F05%2F11%2F%E4%BA%94%E6%9C%88%E5%91%A8%E7%BB%93%2F</url>
    <content type="text"><![CDATA[业精于勤荒于嬉，行成于思毁于随。 &emsp;&emsp;心慌慌的过去了一周，至于为啥心慌慌。我想可能是我的技术还是太菜了吧。 &emsp;&emsp;周二晚上，受人指点关于liunx上采集系统的问题。由于初次接触linux，命令也只会cd、ls之类简单的，所以被指点时，大神一个字母一个字母说着让我输入命令。唉，那种感觉太差劲了。所以这周主要学习了linux相关的命令，初步了解了一些，内心既忧虑又欣喜，忧虑的是问题解决没思路，欣喜的是操作了传说当中的linux，这种感觉和自己电脑上装的linux虚机不一样。现在操作的是真实的环境，运行着项目的环境，此项目就是这半年多改bug的项目，至于项目的部署，环境的搭建还是没操作过。不过有机会得实操一波。 &emsp;&emsp;就这样这一周慌慌的来到了今天-周六。总是感觉自己在无所作为或没完成任务时内心十分的焦虑、慌张。 &emsp;&emsp;转到运维现场环境，不知道在两个月内，还会不会写代码，贴个图展示一些在inspur的代码提交情况吧。 &emsp;&emsp;这一周迷上了历史，正在追《大秦帝国之裂变》，看到了卫鞅在秦国大展自己的博学那段，史称“商鞅变法”。从中看到了秦孝公赢取梁为使自己国家变强的决心与意志，在招进卫鞅后与他商讨三天三夜的治理秦国之策。卫鞅也在讲，变法才能使秦国强大，才能使秦国走上一统天下的道路。看自己的人生道路不也是那样吗，人生的道路自己也要不断变法，不能因循守旧，要灵慧变通，不断寻求新方法，改变自己，使自己变得强大，才能走上幸福的道路，让自己家人过上好日子。]]></content>
      <categories>
        <category>生活</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>周结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello! linux!]]></title>
    <url>%2F2019%2F05%2F08%2Fhello-linux%2F</url>
    <content type="text"><![CDATA[这两天，接触到了久违的linux，然后就被嫌弃了一波 因为之前很少操作liunx系统，分配的任务又是在linux上操作snmp采集，瞬间感觉自己和傻子一样，啥也不懂啥也不会。 在此记录下常用的liunx命令 cd命令它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径123cd /root/home #进入home文件夹cd ./tomcat #切换到当前目录下的tomcat目录cd ../path #切换到上一级目录下的path文件夹 ls命令查看文件与目录的命令，list之意1234-l: 列数长数据串，包含文件的属性与权限数据等 ls -l也可以用ll代替-a: 列出全部文件，连同隐藏文件（开头为.的文件）一起列出来（常用）-h: 将文件容量以较易读的方式（GB，kB等）列出来-R: 连同子目录的内容一起列出来（递归列出），等于该目录下的所有文件都会显示出来 grep命令该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛选加工等等命令格式：grep [选项] ”模式“ [文件] 常用选项1234567891011-E：开启扩展（Extend）的正则表达式-i：忽略大小写（ignore case）-v：只打印没有匹配的（invert），匹配的不打印-n：显示行号-w：匹配的文本只能是单词，而不能是单词的一部分。例如文本中由liker，而我搜的是like，就可以用-w，避免搜到liker-c：显示有多少行被匹配到了，而不是显示被匹配到的内容，同时使用-cv显示有多少行没有被匹配到-o：只显示被模式匹配的字符串--color：将匹配的内容以颜色高亮显示-A n：显示被匹配的字符串所在的行和其后的n行，after-B n：显示被匹配的字符串所在的行和其前的n行，before-C n：显示被匹配的字符串所在的行和其前后的n行，context 模式部分可以直接输入要匹配的字符串这个可以利用fgrep（fast grep）代替提高查找速度，例如查找hello.c文件中print的个数：fgerp -c “print” hello.c 使用基本表达式 . ：任意一个字符 [abc] ：匹配的字符，必须是abc中的一个 [a-zA-Z] ：表示匹配一个字符，这个字符必须是a-z或A-Z这52个字母中的一个。 [^123] ：匹配一个字符，这个字符是除了1、2、3以外的所有字符。 对于一些常用的字符集，系统做了定义： [A-Za-z] 等价于 [[:alpha:]] [0-9] 等价于 [[:digit:]] [A-Za-z0-9] 等价于 [[:alnum:]] tab,space 等空白字符 [[:space:]] [A-Z] 等价于 [[:upper:]] [a-z] 等价于 [[:lower:]] find命令find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多命令格式：find [PATH] [option] [action] （操作符、选项、测试表达式以及动作） 与时间有关的参数1234-mtime n：搜索在n天之前的”一天内“被更改的文件-mtime +n：列出在n天前（不含n天本身）被更改过的文件名-mtime -n：搜索在n天之内（含n天本身）被更改过的文件名-newer file：列出比file还要新的文件名 例如：find /root -mtime 0 ：在当前目录下查找今天之内被改动过的文件 与文件权限及名称相关的参数123456-name：查找文件名为name的文件-size +/-size：找出比size还要大/小的文件，byte单位-type type：查找文件类型为type的文件，type的类型一般由：一般文件（f)、设备文件（b、c）、 目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755； -perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示 -perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示 例如：find . -perm 0755 # 查找当前目录中文件权限的0755的文件find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte 与用户或用户组名有关的参数：-user name : 列出文件所有者为name的文件-group name : 列出文件所属用户组为name的文件-uid n : 列出文件所有者为用户ID为n的文件-gid n : 列出文件所属用户组为用户组ID为n的文件例如：find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件 cp命令命令格式：cp [option] [source] [dest]（cp [选项] [源文件] [目标文件]）该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下12345-a：将文件的特性一起复制-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份 -i ：若目标文件已经存在时，在覆盖时会先询问操作的进行 -r ：递归持续复制，用于目录的复制行为 -u ：目标文件与源文件有差异时才会复制 例如：cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中 mv命令命令格式：cp [option] [source] [dest]（cp [选项] 源文件或目录 目标文件或目录）该命令用于移动文件、目录或更名，move之意123-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i ：若目标文件已经存在，就会询问是否覆盖 -u ：若目标文件已经存在，且比目标文件新，才会更新 例如：mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中mv file1 file2 # 把文件file1重命名为file2 rm命令该命令用于删除文件或目录，remove之间123-f ：就是force的意思，忽略不存在的文件，不会出现警告消息 -i ：互动模式，在删除前会询问用户是否操作 -r ：递归删除，最常用于目录删除，它是一个非常危险的参数 例如：rm -i file # 删除文件file，在删除之前会询问是否进行该操作rm -fr dir # 强制删除目录dir中的所有文件 tail命令（head与之相反）命令格式：tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ]123456-f：用于监视文件的增长-c num：从num字节位置读取指定文件-n：从num行位置读取文件-m Number： 从 Number 多字节字符位置读取指定文件，比方你的文件假设包括中文字，假设指定-c参数，可能导致截断，但使用-m则会避免该问题。-b Number： 从 Number 表示的512字节块位置读取指定文件。-k Number： 从 Number 表示的1KB块位置读取指定文件。 File 指定操作的目标文件名称上述命令中，都涉及到number，假设不指定，默认显示10行。Number前面可使用正负号，表示该偏移从顶部还是从尾部開始计算。tail可运行文件一般在/usr/bin/以下。例如：tali -f tomcat.log # 实时显示最新日志tail -n 100 tomcat.log #显示最后100行数据tail -n -100 tomcat.log #除了前99行不显示外，显示第100行到末尾行 https://blog.csdn.net/q357010621/article/details/80248611]]></content>
      <categories>
        <category>编程</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五一小长假-回家之旅]]></title>
    <url>%2F2019%2F05%2F05%2F%E4%BA%94%E4%B8%80%E5%B0%8F%E9%95%BF%E5%81%87-%E5%9B%9E%E5%AE%B6%E4%B9%8B%E6%97%85%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;转眼五一四天过去了，过的真TM快。还没缓过神呢，已经在公司上班了。由于种种原因决定五一回躺家，回家的路畅快无比，望着窗外的风景，思绪早已超过火车，向着家乡飞驰而去。 五一第1天&emsp;&emsp;一大早收拾完行李📦，便匆忙奔向了火车站，中途本想给弟弟在这边的批发市场买个篮球，逛了一圈也没找到。于是想着还是回家买吧，家里应该便宜，毕竟十八线小镇物价应该没那么高。&emsp;&emsp;取票还好，虽然人多，但是自动取款机也不少啊。票买的晚😕，直接到家的票没了，只能买到中途站的了，下了车再补票 &emsp;&emsp;一路颠簸，铁轨🚝两旁都是树，而且铁轨都穿行在郊区，没啥好看的风景，只有这条河🌊还算广阔 [一条大河~ 波浪宽~] &emsp;&emsp;颠颠簸簸下午终于到达了我的小镇🏰，美丽而又漂亮的**。下了车在街道找了半天看到一家卖体育器材的店铺，进去逛了下，最便宜的蓝球也100多，遂，离开。没想到那么贵💰。又溜达半天一个小妹妹过来塞了张叫了只鸡优惠券给我，没想到小镇上也有了这样的店铺。后来在一家文具店买了一套文具✏和一个篮球🏀35大洋，还可以，几年级的小孩子打完全足够。&emsp;&emsp;坐着公交到站，一下车各种花香便扑鼻而来，天蓝蓝，地绿油油，一阵微风吹来，仿佛姑娘在轻抚我的脸，异常舒服。不过偶尔还有牛粪的味道😂，远处的山上几座风车在悠闲的转动着。一切都充满了乡村气息，宁静而又平和。 手拙拍的太丑👇👇👇 回到家弟弟看见篮球高兴的欢呼雀跃跳了起来😂😂，傍晚我爸爸也回到了家。 五一第2天&emsp;&emsp;回到家，大家都知道，早晨别想睡懒觉。一大早就会喊你起床吃饭，甭管多早，他们都会说 “都几点了还不起床，太阳都到哪了，赶紧起床吃饭”，翻身看表6点半🙃。弟弟在家可能也早起习惯了，起来也开始摇晃我，喊我打球。&emsp;&emsp;现在的时节，地里还没有太多的农活，吃过饭便没事了。我爸开着三轮车带着我妈，去地里打打农药，我和弟弟也没啥事，打篮球累了，就躺沙发看看电视。中午我妈在菜园子里割了一把韭菜，给我们烙饼吃，不知为啥家里烧柴的大铁锅，做出来的什么都特别好吃，充满了家的味道。 带大家领略一下我家周围 村里种的树不少，拍出来有种住在少数民族的寨子里一样😂👇👇👇 震惊，乡村恐龙出没，被抓拍 站在楼顶拍的，我家种的槐树，下面还有无花果，山楂，石榴，桑葚 下午偶尔翻出日记本，看下封面，充满了无限梦想的中学时代 五一第3天&emsp;&emsp;昨天晚上我妈从鸡窝里捉了一只两年的老公鸡，绑了起来，说明天给你们杀鸡吃。我妈说杀鸡吃时，我弟弟还拦着不让，炒好后左手拿着鸡腿，右手筷子不停歇，含泪吃了两大碗（哈哈😂，开玩笑，杀鸡我俩还没起床呢） 五一最后一天&emsp;&emsp;早晨起床后，没看见我爸，我妈说一大早就坐车回青岛了。有点小伤心，为了生活分分合合。我吃过饭也该起程了，由于没坐上去镇里的公交，我妈怕我火车晚点，开着三轮车绕过盘山路送我到了镇上。 山的背面👇👇👇 &emsp;&emsp;在我以往的记忆里，每逢割麦子，就到了放暑假的时候了，而且天很热，当然妈妈也会给我一块，五毛的让我去买雪糕吃，炎热的夏季，一块雪糕入口，啊~，怎一爽子了得。那时候割麦子挑回家，等一两天后，大家就开始打麦子。由于小时候家家都不是很富裕，一个村也就一个打麦机，放在大队里（村委会），然后很多人用手巾包着头，抬着打麦机，挨家挨户轮流打，轮流帮忙。打完后，小麦秸秆往往堆成一堆，和小山一样。和小伙伴爬上去踩在上面，跳啊跳的。很有弹性，常常高兴的没头没脑。那时候，打完小麦就会放鞭炮庆祝，还会发糖吃，庆祝大丰收，也感谢帮忙的人。而现在人民生活水平提高，很多人都出去打工了，没出去打工的，家里也会有自家买的打麦机，两个人差不多就能完成。但是总感觉少了些什么。 路旁养蜂的人，一路有很多，他们大都待一段时间，就会迁移到其他地方继续采蜜，一年到处奔波，也挺不容易的。记得小时候学校旁边有养蜂的，经常被蛰，脸肿的和馒头一样，眼睛眯成一条线都快睁不开了，然而还是会去招惹它，乐此不疲。 到了火车站人挤人，站了差不多三个小时，就又回到了工作的城市，山东的省会—泉城济南。]]></content>
      <categories>
        <category>生活</category>
        <category>日常</category>
      </categories>
      <tags>
        <tag>五一</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100-500+状态码详解]]></title>
    <url>%2F2019%2F04%2F29%2F100-500-%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1xx响应信息提示这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个1xx 100 - Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新） 101 - Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新） 2xx - 成功这类状态代码表明服务器成功地接受了客户端请求 200 - OK 一切正常，对GET和POST请求的应答文档跟在后面。 201 - Created 服务器已经创建了文档，Location头给出了它的URL。 202 - Accepted 已经接受请求，但处理尚未完成。 203 - Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝，非权威性信息（HTTP 1.1新）。 204 - No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 - Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。 206 - Partial Content 客户发送了一个带有Range头的GET请求（分块请求），服务器完成了它（HTTP 1.1新）。 3xx - 重定向客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求 300 - Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 301 - Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，GET、HEAD请求时浏览器应该自动地访问新的URL。 302 - Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使 用。例如，如果浏览器错误地请求 http://host/~user （缺少了后面的斜杠），有的服务器返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET、HEAD时浏览器才会自动重定向。请参见307。 303 - See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取，即该状态码存在的最主要意义是为了处理POST请求重定向到GET请求的情况（HTTP 1.1新）。 304 - Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。 305 - Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。 307 - Temporary Redirect 许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时 才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307，301，302应答，则浏览器只能跟随对GET、HEAD请求的重定向。（HTTP 1.1新） 4xx - 客户端错误发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息 400 - Bad Request 请求出现语法错误。 401 - Unauthorized 访问被拒绝，客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在 填写合适的Authorization头后再次发出请求。IIS 定义了许多不同的 401 错误，它们指明更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在 IIS 日志中显示： 401.1 - 登录失败。 401.2 - 服务器配置导致登录失败。 401.3 - 由于 ACL 对资源的限制而未获得授权。 401.4 - 筛选器授权失败。 401.5 - ISAPI/CGI 应用程序授权失败。 401.7 –访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。 403 - Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。禁止访问：IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因： 403.1 - 执行访问被禁止。 403.2 - 读访问被禁止。 403.3 - 写访问被禁止。 403.4 - 要求 SSL。 403.5 - 要求 SSL 128。 403.6 - IP 地址被拒绝。 403.7 - 要求客户端证书。 403.8 - 站点访问被拒绝。 403.9 - 用户数过多。 403.10 - 配置无效。 403.11 - 密码更改。 403.12 - 拒绝访问映射表。 403.13 - 客户端证书被吊销。 403.14 - 拒绝目录列表。 403.15 - 超出客户端访问许可。 403.16 - 客户端证书不受信任或无效。 403.17 - 客户端证书已过期或尚未生效。 403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。 403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。 403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。 404 - Not Found 无法找到指定位置的资源。这也是一个常用的应答。 404.0 -（无） – 没有找到文件或目录。 404.1 - 无法在所请求的端口上访问 Web 站点。 404.2 - Web 服务扩展锁定策略阻止本请求。 404.3 - MIME 映射策略阻止本请求。 405 - Method Not Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用，用来访问本页面的 HTTP 谓词不被允许（方法不被允许）（HTTP 1.1新） 406 - Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容，客户端浏览器不接受所请求页面的 MIME 类型（HTTP 1.1新）。 407 - Proxy Authentication Required 要求进行代理身份验证，类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新） 408 - Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新） 409 - Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新） 410 - Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。（HTTP 1.1新） 411 - Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新） 412 - Precondition Failed 请求头中指定的一些前提条件失败（HTTP 1.1新）。 413 – Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。 414 - Request URI Too Long URI太长（HTTP 1.1新）。 415 – 不支持的媒体类型。 416 – Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新） * 417 – 执行失败。 423 – 锁定的错误。 5xx - 服务器错误服务器由于遇到错误而不能完成该请求 500 - Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。 500.12 - 应用程序正忙于在 Web 服务器上重新启动。 500.13 - Web 服务器太忙。 500.15 - 不允许直接请求 Global.asa。 500.16 – UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。 500.18 – URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。 500.100 - 内部 ASP 错误。 501 - Not Implemented 服务器不支持实现请求所需要的功能，页眉值指定了未实现的配置。例如，客户发出了一个服务器不支持的PUT请求。 502 - Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 亦说Web 服务器用作网关或代理服务器时收到了无效响应。 502.1 - CGI 应用程序超时。 502.2 - CGI 应用程序出错。 503 - Service Unavailable 服务不可用，服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。这个错误代码为 IIS 6.0 所专用。 504 - Gateway Timeout 网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新） 。 505 - HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新） 说明根据RFC2616D定义，对于HTTP Response响应码301、302、307，如果请求不是GET或者HEAD，而response返回的状态码是302，那么浏览器禁止重定向到新的请求，除非得到用户的确认！因为这可能会导致请求条件变更而出现。参考：RFC2616 Hypertext Transfer Protocol – HTTP/1.1相应的Java的HTTP Client包就是根据这个规范进行处理的，如果对返回Response状态码是307，301，302的POST请求设置setFollowRedirects，系统就会报错：java.lang.IllegalArgumentException: Entity enclosing requests cannot be redirected without user intervention！如果可以的话，把POST改成Get后即使在307响应码的情况下也能自动重定向 502 Bad Gateway：tomcat没有启动起来 504 Gateway Time-out: nginx报出来的错误，一般是nginx做为反向代理服务器的时候，所连接的应用服务器譬如tomcat无相应导致的 302（临时移动） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求，302响应时，临时URL通过Location 字段返回给客户端。 304（未修改） 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。 307 - Temporary Redirect 许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时 才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307，301，302应答，则浏览器只能跟随对GET、HEAD请求的重定向。（HTTP 1.1新）]]></content>
      <categories>
        <category>编程</category>
        <category>html</category>
      </categories>
      <tags>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[故乡的路]]></title>
    <url>%2F2019%2F04%2F28%2F%E6%95%85%E4%B9%A1%E7%9A%84%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[“希望是本无所谓有，本无所谓无的，这正如地上的路，其实地上本没有路，走的人多了，也便成了路” 《故乡》-鲁迅&emsp;&emsp;小时候走的“路”，大多都是长辈们铺好的。正如嗷嗷待哺的乌鸦，张着嘴，摇头晃脑的等着鸦妈妈把虫儿塞到嘴里一样，一切都是按照他们的计划向前行走着。你也不用担心前面有“坑”，或者其他的什么危险，因为他们总会说我走的路比你走的桥都多，不会害你走弯路的，与是你更加自信的向他们安排的方向跑了起来，充满了好奇和向往。 &emsp;&emsp;后来随着我们慢慢的长大，便发现他们的有些路已经不是我们想要去的地方了，于是便自己开疆破土，四处乱撞，一步一步激动又害怕的向着自己心中的方向试探去，终于哪一日跌进泥潭，便想起了小时候父母铺好的路了，然而不过两三天，又朝向心中不知是黑暗还是黎明的方向走去…]]></content>
      <categories>
        <category>生活</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo写文章基本操作及Markdown语法]]></title>
    <url>%2F2019%2F04%2F28%2Fhexo%E5%86%99%E6%96%87%E7%AB%A0%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[hexo写博客基础操作，包含常用markdown语法，hexo创建页面，发布文章等 官网提供语法说明：Hexo基础操作 创建文章和发布创建新页面： 1hexo new newpapername 然后在source/_post中打开markdown文件，就可以开始编辑了当你写完的时候，再执行下面三行命令 123hexo clean：清除了你之前生成的东西，也可以不加hexo generate：顾名思义，生成静态文章，可以用hexo g缩写hexo deploy：部署文章，可以用hexo d缩写 主要文件头信息生成的md文件头信息说明 1234title：文章标题date：生成时间tags：标签，多个标签书写格式---&gt;[1,2,3]categories：分类 加密头信息加密文章书写格式（需要安装插件） 123password: 该博客加密使用的密码abstract: 该博客的摘要，会显示在博客的列表页message: 查看博客时，密码输入框上面的描述性文字 置顶方式头信息再头信息中加入（需要安装插件支持） 1top: num（num越大越靠前） 自定义摘要在摘要后加下面代码 1&lt;!-- more --&gt; 添加404页面在 hexo/source 目录内新建 404.html设置元数据信息，如果不想套用主题布局可设置 layout 为 false 12layout: false title: &quot;My Blog Name | 404&quot; 创建自定义页面1hexo new page pageName 页面配置 123456layout: pagetitle: pageTitle # 必须，页面名称description: # 页面二级标题，描述性文字comments: false # 禁用评论，可选，默认开启reward: false # 禁用打赏，可选，默认开启urlname: xxxxxx # 更换本文地址路径 适用next主题的操作Bootstrap Callout1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中class值可以为default primary success info warning danger效果如下 Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) 文本居中的引用123456789&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class=&quot;blockquote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;blah blah blah&lt;/blockquote&gt;&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125;&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; 显示效果如下 blah blah blah 常用Makedown语法控制图片大小位置直接使用html语法，其中div的alien可居左/中/右，img可设置宽高 12&lt;div align=center&gt;&lt;img src="链接" width="宽度" height="高度" alt="图片名称"&gt; 段落首行缩进 方法一 123半方大的空白&amp;ensp;或&amp;#8194;(缩进1/2个中文)全方大的空白&amp;emsp;或&amp;#8195;(缩进1个中文)不断行的空白格&amp;nbsp;或&amp;#160;(缩进1/4个中文) 方法二 推荐全角空格，切换到全角模式下（一般的中文输入法都是按 shift + space）输入两个空格就行了。这个相对来说稍微干净一点，而且宽度是整整两个汉字，很整齐 表格123|标题一|标题二|标题三||:-|:-:|-:||居左|居中|居右| 标题一 标题二 标题三 居左 居中 居右 超链接1More info: [Deployment](https://hexo.io/docs/deployment.html) More info: Deployment 图片 引用网络图片 1![图片描述](http://wjup-git.kuaiyunds.com/wjup-git/wang_banner.jpg &quot;title&quot;) 引用本地图片（插件支持）,图片放在博文同名文件夹下 1&#123;% asset_img xxx.jpg This is an example image %&#125; 加粗、斜体、又斜又粗、着重突出、删除线1对于__加粗__和对于*斜体*的***结合***`处理`~~啊呀呦~~ 对于加粗和对于斜体的结合处理啊呀呦 任务列表123- [x] 任务1，已完成;- [x] 任务2，已完成;- [ ] 任务3，未完成; 任务1，已完成; 任务2，已完成; 任务3，未完成; 引用1234&gt; 唐朝&gt;&gt; 文化&gt;&gt;&gt; 李白&gt;&gt;&gt;&gt; 路漫漫其修远兮，吾将上下而求索 唐朝 文化 李白 路漫漫其修远兮，吾将上下而求索 无序列表、有序列表123456* 写法一+ 写法二- 写法三1. 排序一2. 排序二5. 自动校正序号三 写法一 写法二 写法三 排序一 排序二 自动校正序号三 分割线123****----____]]></content>
      <categories>
        <category>编程</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
